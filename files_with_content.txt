Файл: .env
Содержимое:
PORT=3000
JWT_SECRET=DimaZaebal




Файл: README.md
Содержимое:
банк написанный нашими руками!!!!


Файл: cmd\main.go
Содержимое:
package main

import (
	"bank-api/internal/handlers"
	"bank-api/internal/services"
	"bank-api/pkg/database"
	"log"
	"os"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/gofiber/fiber/v2/middleware/logger"
	"github.com/gofiber/fiber/v2/middleware/recover"
	"github.com/joho/godotenv"
)

func main() {
	if err := godotenv.Load(); err != nil {
		log.Println("Не найден .env файл, используем переменные окружения")
	}

	dbPath := os.Getenv("DB_PATH")
	if dbPath == "" {
		dbPath = "bank.db"
	}
	db, err := database.InitDB(dbPath)
	if err != nil {
		log.Fatalf("Ошибка инициализации БД: %v", err)
	}
	defer db.Close()

	jwtSecret := os.Getenv("JWT_SECRET")
	if jwtSecret == "" {
		log.Fatal("JWT_SECRET не установлен")
	}

	var (
		transactionService = services.NewTransactionService(db, jwtSecret)
		authService        = services.NewAuthService(db, jwtSecret)
		accountService     = services.NewAccountService(db, jwtSecret)
	)

	h := handlers.NewHandler(transactionService, authService, accountService)

	app := fiber.New(fiber.Config{
		ErrorHandler: h.ErrorHandler,
	})

1п
	app.Use(recover.New())
	app.Use(logger.New())

	api := app.Group("/api")
	api.Post("/register", h.Register)
	api.Post("/login", h.Login)

	protected := api.Group("/", h.AuthMiddleware)
	protected.Get("/accounts", h.GetAccounts)
	protected.Post("/transfer", h.Transfer)
	protected.Post("/deposit/:id", h.Deposit)
	protected.Post("/withdraw/:id", h.Withdraw)

	port := os.Getenv("PORT")
	if port == "" {
		port = "3000"
	}
	log.Printf("Сервер запущен на порту %s", port)
	log.Fatal(app.Listen(":" + port))
}


Файл: files_with_content.txt
Содержимое:
Файл: .env
Содержимое:
PORT=3000
JWT_SECRET=DimaZaebal

Файл: 1.go
Содержимое:
package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
)

func main() {
	// Укажите путь к директории, которую нужно просканировать
	dir := "./" // Текущая директория

	// Создание или открытие файла для записи
	file, err := os.Create("files_with_content.txt")
	if err != nil {
		fmt.Println("Ошибка при создании файла:", err)
		return
	}
	defer file.Close()

	// Функция для обхода директорий
	err = filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() { // Проверяем, что это не директория
			// Записываем путь к файлу в файл
			_, err := file.WriteString("Файл: " + path + "\n")
			if err != nil {
				return err
			}

			// Читаем содержимое файла
			content, err := ioutil.ReadFile(path)
			if err != nil {
				return err
			}

			// Записываем содержимое файла в файл
			_, err = file.WriteString("Содержимое:\n" + string(content) + "\n\n")
			if err != nil {
				return err
			}
		}
		return nil
	})

	if err != nil {
		fmt.Println("Ошибка при обходе директорий:", err)
		return
	}

	fmt.Println("Список файлов и их содержимое успешно сохранены в files_with_content.txt")
}


Файл: README.md
Содержимое:
банк написанный нашими руками!!!!


Файл: cmd\main.go
Содержимое:
package main

import (
	"bank-api/internal/handlers"
	"bank-api/internal/services"
	"bank-api/pkg/database"
	"log"
	"os"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/gofiber/fiber/v2/middleware/logger"
	"github.com/gofiber/fiber/v2/middleware/recover"
	"github.com/joho/godotenv"
)

func main() {
	if err := godotenv.Load(); err != nil {
		log.Println("Не найден .env файл, используем переменные окружения")
	}

	dbPath := os.Getenv("DB_PATH")
	if dbPath == "" {
		dbPath = "bank.db"
	}
	db, err := database.InitDB(dbPath)
	if err != nil {
		log.Fatalf("Ошибка инициализации БД: %v", err)
	}
	defer db.Close()

	jwtSecret := os.Getenv("JWT_SECRET")
	if jwtSecret == "" {
		log.Fatal("JWT_SECRET не установлен")
	}

	var (
		transactionService = services.NewTransactionService(db, jwtSecret)
		authService        = services.NewAuthService(db, jwtSecret)
		accountService     = services.NewAccountService(db, jwtSecret)
	)

	h := handlers.NewHandler(transactionService, authService, accountService)

	app := fiber.New(fiber.Config{
		ErrorHandler: h.ErrorHandler,
	})

1п
	app.Use(recover.New())
	app.Use(logger.New())

	api := app.Group("/api")
	api.Post("/register", h.Register)
	api.Post("/login", h.Login)

	protected := api.Group("/", h.AuthMiddleware)
	protected.Get("/accounts", h.GetAccounts)
	protected.Post("/transfer", h.Transfer)
	protected.Post("/deposit/:id", h.Deposit)
	protected.Post("/withdraw/:id", h.Withdraw)

	port := os.Getenv("PORT")
	if port == "" {
		port = "3000"
	}
	log.Printf("Сервер запущен на порту %s", port)
	log.Fatal(app.Listen(":" + port))
}


Файл: files_with_content.txt


Файл: go.mod
Содержимое:
module bank-api

go 1.21

require (
	github.com/gofiber/fiber/v2 v2.52.6
	github.com/golang-jwt/jwt/v4 v4.5.1
	github.com/joho/godotenv v1.5.1
	github.com/mattn/go-sqlite3 v1.14.24
	golang.org/x/crypto v0.32.0
)

require (
	github.com/andybalholm/brotli v1.1.1 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/klauspost/compress v1.17.11 // indirect
	github.com/mattn/go-colorable v0.1.14 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasthttp v1.58.0 // indirect
	github.com/valyala/tcplisten v1.0.0 // indirect
	golang.org/x/sys v0.29.0 // indirect
)


Файл: go.sum
Содержимое:
github.com/andybalholm/brotli v1.1.1 h1:PR2pgnyFznKEugtsUo0xLdDop5SKXd5Qf5ysW+7XdTA=
github.com/andybalholm/brotli v1.1.1/go.mod h1:05ib4cKhjx3OQYUY22hTVd34Bc8upXjOLL2rKwwZBoA=
github.com/gofiber/fiber/v2 v2.52.6 h1:Rfp+ILPiYSvvVuIPvxrBns+HJp8qGLDnLJawAu27XVI=
github.com/gofiber/fiber/v2 v2.52.6/go.mod h1:YEcBbO/FB+5M1IZNBP9FO3J9281zgPAreiI1oqg8nDw=
github.com/golang-jwt/jwt/v4 v4.5.1 h1:JdqV9zKUdtaa9gdPlywC3aeoEsR681PlKC+4F5gQgeo=
github.com/golang-jwt/jwt/v4 v4.5.1/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/klauspost/compress v1.17.11 h1:In6xLpyWOi1+C7tXUUWv2ot1QvBjxevKAaI6IXrJmUc=
github.com/klauspost/compress v1.17.11/go.mod h1:pMDklpSncoRMuLFrf1W9Ss9KT+0rH90U12bZKk7uwG0=
github.com/mattn/go-colorable v0.1.14 h1:9A9LHSqF/7dyVVX6g0U9cwm9pG3kP9gSzcuIPHPsaIE=
github.com/mattn/go-colorable v0.1.14/go.mod h1:6LmQG8QLFO4G5z1gPvYEzlUgJ2wF+stgPZH1UqBm1s8=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/mattn/go-sqlite3 v1.14.24 h1:tpSp2G2KyMnnQu99ngJ47EIkWVmliIizyZBfPrBWDRM=
github.com/mattn/go-sqlite3 v1.14.24/go.mod h1:Uh1q+B4BYcTPb+yiD3kU8Ct7aC0hY9fxUwlHK0RXw+Y=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=
github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
github.com/valyala/fasthttp v1.58.0 h1:GGB2dWxSbEprU9j0iMJHgdKYJVDyjrOwF9RE59PbRuE=
github.com/valyala/fasthttp v1.58.0/go.mod h1:SYXvHHaFp7QZHGKSHmoMipInhrI5StHrhDTYVEjK/Kw=
github.com/valyala/tcplisten v1.0.0 h1:rBHj/Xf+E1tRGZyWIWwJDiRY0zc1Js+CV5DqwacVSA8=
github.com/valyala/tcplisten v1.0.0/go.mod h1:T0xQ8SeCZGxckz9qRXTfG43PvQ/mcWh7FwZEA7Ioqkc=
github.com/xyproto/randomstring v1.0.5 h1:YtlWPoRdgMu3NZtP45drfy1GKoojuR7hmRcnhZqKjWU=
github.com/xyproto/randomstring v1.0.5/go.mod h1:rgmS5DeNXLivK7YprL0pY+lTuhNQW3iGxZ18UQApw/E=
golang.org/x/crypto v0.32.0 h1:euUpcYgM8WcP71gNpTqQCn6rC2t6ULUPiOzfWaXVVfc=
golang.org/x/crypto v0.32.0/go.mod h1:ZnnJkOaASj8g0AjIduWNlq2NRxL0PlBrbKVyZ6V/Ugc=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=
golang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=


Файл: internal\handlers\handlers.go
Содержимое:
// Path: internal/handlers/handlers.go
package handlers

import (
	"bank-api/internal/models"
	"bank-api/internal/services"
	"errors"
	"fmt"
	"github.com/gofiber/fiber/v2"
	"strconv"
)

// Handler holds dependencies for request handling.
type Handler struct {
	transactionService services.TransactionService
	authService        services.AuthService
	accountService     services.AccountService
}

// NewHandler creates a new Handler instance.
func NewHandler(ts services.TransactionService, as services.AuthService, acs services.AccountService) *Handler {
	return &Handler{
		transactionService: ts,
		authService:        as,
		accountService:     acs,
	}
}

// Custom error type to include context
type AppError struct {
	Code    int    `json:"-"`       // HTTP Status Code
	Message string `json:"message"` // User-friendly error message
	Details string `json:"details"` // Technical details for logging/debugging
	Err     error  `json:"-"`       // Original error
}

func (e *AppError) Error() string {
	return fmt.Sprintf("AppError: %s (Code: %d, Details: %s, OriginalError: %v)", e.Message, e.Code, e.Details, e.Err)
}

// ErrorHandler ошибки от фибера
func (h *Handler) ErrorHandler(c *fiber.Ctx, err error) error {
	// Log the error (consider using a structured logger)
	fmt.Printf("Error: %v\n", err)

	// Default values
	code := fiber.StatusInternalServerError
	message := "Internal Server Error"
	details := ""

	var appErr *AppError
	if errors.As(err, &appErr) {
		code = appErr.Code
		message = appErr.Message
		details = appErr.Details
	} else if e, ok := err.(*fiber.Error); ok {
		// Handle Fiber errors
		code = e.Code
		message = e.Message
	} else {
		// Generic error; log the underlying error for debugging
		details = err.Error()
	}

	return c.Status(code).JSON(fiber.Map{
		"error":   message,
		"details": details, // Include details for non-production environments
	})
}

// Обработчик регистрации
func (h *Handler) Register(c *fiber.Ctx) error {
	var req models.AuthRequest
	if err := c.BodyParser(&req); err != nil {
		return &AppError{Code: fiber.StatusBadRequest, Message: "Invalid request format", Details: err.Error(), Err: err}
	}

	if err := h.authService.Register(req.Username, req.Password); err != nil {
		// Check for specific errors like user already exists
		var appErr *services.AppError
		if errors.As(err, &appErr) {
			return appErr
		}
		return &AppError{Code: fiber.StatusInternalServerError, Message: "Registration failed", Details: err.Error(), Err: err}
	}

	return c.Status(fiber.StatusCreated).JSON(fiber.Map{"message": "Registration successful"})
}

// Обработчик авторизации
func (h *Handler) Login(c *fiber.Ctx) error {
	var req models.AuthRequest
	if err := c.BodyParser(&req); err != nil {
		return &AppError{Code: fiber.StatusBadRequest, Message: "Invalid request format", Details: err.Error(), Err: err}
	}

	token, err := h.authService.Login(req.Username, req.Password)
	if err != nil {
		var appErr *services.AppError
		if errors.As(err, &appErr) {
			return appErr
		}
		return &AppError{Code: fiber.StatusUnauthorized, Message: "Login failed", Details: err.Error(), Err: err}
	}

	return c.JSON(fiber.Map{"token": token})
}

// AuthMiddleware Обработчик JWT авторизации
func (h *Handler) AuthMiddleware(c *fiber.Ctx) error {
	if c.Method() == "OPTIONS" {
		return c.Next()
	}

	authHeader := c.Get("Authorization")
	if authHeader == "" {
		return &AppError{Code: fiber.StatusUnauthorized, Message: "Missing token", Details: "Authorization header is empty"}
	}

	var token string
	_, err := fmt.Sscanf(authHeader, "Bearer %s", &token)
	if err != nil {
		return &AppError{Code: fiber.StatusUnauthorized, Message: "Invalid token format", Details: err.Error()}
	}

	claims, err := h.authService.ValidateToken(token)
	if err != nil {
		return &AppError{Code: fiber.StatusUnauthorized, Message: "Invalid token", Details: err.Error()}
	}

	c.Locals("user", claims)
	return c.Next()
}

// GetAccounts извлекает учетные записи пользователей.....
func (h *Handler) GetAccounts(c *fiber.Ctx) error {
	claims, ok := c.Locals("user").(*models.Claims)
	if !ok {
		return &AppError{Code: fiber.StatusInternalServerError, Message: "Failed to retrieve user claims", Details: "User claims were not of the expected type"}
	}

	accounts, err := h.accountService.GetAccounts(claims.UserID)
	if err != nil {
		var appErr *services.AppError

		if errors.As(err, &appErr) {
			return appErr
		}
		return &AppError{Code: fiber.StatusInternalServerError, Message: "Failed to retrieve accounts", Details: err.Error(), Err: err}
	}

	return c.JSON(accounts)
}

// Обработчик переводов средств
func (h *Handler) Transfer(c *fiber.Ctx) error {
	claims, ok := c.Locals("user").(*models.Claims)
	if !ok {
		return &AppError{Code: fiber.StatusInternalServerError, Message: "Failed to retrieve user claims", Details: "User claims were not of the expected type"}
	}
	var req models.TransferRequest

	if err := c.BodyParser(&req); err != nil {
		return &AppError{Code: fiber.StatusBadRequest, Message: "Invalid request format", Details: err.Error(), Err: err} // АААА ошибка!
	}

	if err := h.transactionService.ProcessTransfer(&req, claims); err != nil {
		var appErr *services.AppError
		if errors.As(err, &appErr) {
			return appErr
		}
		return &AppError{Code: fiber.StatusBadRequest, Message: "Transfer failed", Details: err.Error(), Err: err}
	}

	return c.JSON(fiber.Map{"message": "Transfer successful"})
}

// Обработчик пополнения счета
func (h *Handler) Deposit(c *fiber.Ctx) error {
	claims, ok := c.Locals("user").(*models.Claims)
	if !ok {
		return &AppError{Code: fiber.StatusInternalServerError, Message: "Failed to retrieve user claims", Details: "User claims were not of the expected type"}
	}
	accountID, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return &AppError{Code: fiber.StatusBadRequest, Message: "Invalid account ID", Details: err.Error(), Err: err}
	}

	var req models.TransactionRequest
	if err := c.BodyParser(&req); err != nil {
		return &AppError{Code: fiber.StatusBadRequest, Message: "Invalid request format", Details: err.Error(), Err: err}
	}

	req.AccountID = accountID // Устанавливаем AccountID
	if err := h.transactionService.ProcessDeposit(&req, claims); err != nil {
		var appErr *services.AppError
		if errors.As(err, &appErr) {
			return appErr
		}
		return &AppError{Code: fiber.StatusBadRequest, Message: "Deposit failed", Details: err.Error(), Err: err}
	}

	return c.JSON(fiber.Map{
		"message":       "Deposit successful",
		"transactionID": req.TransactionID, // Возвращаем transactionID
	})
}

// Обработчик вывода средств со счеавта
func (h *Handler) Withdraw(c *fiber.Ctx) error {
	claims, ok := c.Locals("user").(*models.Claims)
	if !ok {
		return &AppError{Code: fiber.StatusInternalServerError, Message: "Failed to retrieve user claims", Details: "User claims were not of the expected type"}
	}
	var accountID, err = strconv.Atoi(c.Params("id"))
	if err != nil {
		return &AppError{Code: fiber.StatusBadRequest, Message: "Invalid account ID", Details: err.Error(), Err: err}
	}

	var req models.TransactionRequest
	if err := c.BodyParser(&req); err != nil {
		return &AppError{Code: fiber.StatusBadRequest, Message: "Invalid request format", Details: err.Error(), Err: err}
	}
	req.AccountID = accountID
	if err := h.transactionService.ProcessWithdraw(&req, claims); err != nil {
		var appErr *services.AppError
		if errors.As(err, &appErr) {
			return appErr
		}
		return &AppError{Code: fiber.StatusBadRequest, Message: "Withdrawal failed", Details: err.Error(), Err: err}
	}

	return c.JSON(fiber.Map{
		"message":       "Withdrawal successful",
		"transactionID": req.TransactionID, // Возвращаем transactionID
	})
}


Файл: internal\models\models.go
Содержимое:
// Path: internal/models/models.go
package models

import (
	"github.com/golang-jwt/jwt/v4"
)

// Структура Базы данных

// здесь хранится пароль и имя и ID
type User struct {
	ID        int    `json:"id"`
	Username  string `json:"username"`
	Password  string `json:"-"`
	CreatedAt string `json:"created_at"`
}

// При создании аккаунта получается это тут хранится баланс и ID
type Account struct {
	ID          int     `json:"id"`      // Это надо
	UserID      int     `json:"user_id"` // и это тоже
	Balance     float64 `json:"balance"`
	BalanceHash string  `json:"balance_hash"`
	CreatedAt   string  `json:"created_at"`
}

// Записывает в базу данных все входы в аккаунт
type AuthRequest struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// // Записывает в базу даннывх все транзакции, пополнения, выводы
type TransactionRequest struct {
	AccountID     int     `json:"account_id"`
	Amount        float64 `json:"amount"`
	TransactionID string  `json:"transaction_id"` // Надо сделать что-бы еще этот ID возвращался во время реквеста, это чтоб админы нашли его.
}

// Записывает в базу данных переводы между счетами
type TransferRequest struct {
	FromID int     `json:"from_id"`
	ToID   int     `json:"to_id"`
	Amount float64 `json:"amount"`
}

// JWT Проверка
type Claims struct {
	UserID int `json:"user_id"`
	jwt.RegisteredClaims
}


Файл: internal\services\account_service.go
Содержимое:
// Path: internal/services/account_service.go
package services

import (
	"bank-api/internal/models"
	"bank-api/pkg/utils"
	"database/sql"
	"fmt"
)

// AccountService handles account-related operations.
type AccountService interface {
	GetAccounts(userID int) ([]models.Account, error)
}

type accountService struct {
	db        *sql.DB
	secretKey string
}

// NewAccountService creates a new AccountService.
func NewAccountService(db *sql.DB, secretKey string) AccountService {
	return &accountService{
		db:        db,
		secretKey: secretKey,
	}
}

// GetAccounts retrieves all accounts for a given user.
func (s *accountService) GetAccounts(userID int) ([]models.Account, error) {
	query := `
        SELECT id, user_id, balance, balance_hash, created_at
        FROM accounts
        WHERE user_id = ?
    `
	rows, err := s.db.Query(query, userID)
	if err != nil {
		return nil, &AppError{Code: 500, Message: "Failed to query accounts", Details: err.Error(), Err: err}
	}
	defer rows.Close()

	var accounts []models.Account
	for rows.Next() {
		var acc models.Account
		if err := rows.Scan(&acc.ID, &acc.UserID, &acc.Balance, &acc.BalanceHash, &acc.CreatedAt); err != nil {
			return nil, &AppError{Code: 500, Message: "Failed to scan account row", Details: err.Error(), Err: err}
		}

		// Verify balance integrity
		expectedHash := utils.CreateHMAC(fmt.Sprintf("%f:%d", acc.Balance, acc.ID), []byte(s.secretKey))
		if acc.BalanceHash != expectedHash {
			return nil, &AppError{Code: 500, Message: "Balance integrity check failed", Details: fmt.Sprintf("account_id: %d", acc.ID)}
		}

		accounts = append(accounts, acc)
	}

	if err = rows.Err(); err != nil {
		return nil, &AppError{Code: 500, Message: "Error iterating account rows", Details: err.Error(), Err: err}
	}

	return accounts, nil
}


Файл: internal\services\auth_service.go
Содержимое:
// Path: internal/services/auth_service.go
package services

import (
	"bank-api/internal/models"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/golang-jwt/jwt/v4"
	"golang.org/x/crypto/bcrypt"
)

// AuthService handles user authentication and registration.
type AuthService interface {
	Register(username, password string) error
	Login(username, password string) (string, error)
	ValidateToken(tokenString string) (*models.Claims, error)
}

type authService struct {
	db     *sql.DB
	jwtKey string
}

// NewAuthService creates a new AuthService.
func NewAuthService(db *sql.DB, jwtSecret string) AuthService {
	return &authService{
		db:     db,
		jwtKey: jwtSecret,
	}
}

// Register registers a new user.
func (s *authService) Register(username, password string) error {
	tx, err := s.db.Begin()
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to start transaction", Details: err.Error(), Err: err}
	}
	defer tx.Rollback() // Ensure rollback on failure.

	// Check if user already exists.
	var exists bool
	err = tx.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE username = ?)", username).Scan(&exists)
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to check user existence", Details: err.Error(), Err: err}
	}
	if exists {
		return &AppError{Code: 400, Message: "User already exists", Details: fmt.Sprintf("username: %s", username)}
	}

	// Hash the password.
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to hash password", Details: err.Error(), Err: err}
	}

	// Insert the new user.
	res, err := tx.Exec("INSERT INTO users (username, password) VALUES (?, ?)", username, hashedPassword)
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to insert user", Details: err.Error(), Err: err}
	}

	userID, err := res.LastInsertId()
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to get last inserted ID", Details: err.Error(), Err: err}
	}

	// Create a default account for the user.
	initialHash := CalculateBalanceHash(0, int(userID), s.jwtKey) // Use consistent hashing
	_, err = tx.Exec("INSERT INTO accounts (user_id, balance, balance_hash) VALUES (?, ?, ?)", userID, 0, initialHash)
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to create initial account", Details: err.Error(), Err: err}
	}

	if err := tx.Commit(); err != nil {
		return &AppError{Code: 500, Message: "Failed to commit transaction", Details: err.Error(), Err: err}
	}

	return nil
}

// Login authenticates a user and returns a JWT.
func (s *authService) Login(username, password string) (string, error) {
	var user models.User
	err := s.db.QueryRow("SELECT id, password FROM users WHERE username = ?", username).Scan(&user.ID, &user.Password)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return "", &AppError{Code: 401, Message: "Invalid credentials", Details: "User not found"}
		}
		return "", &AppError{Code: 500, Message: "Failed to query user", Details: err.Error(), Err: err}
	}

	// Check password.
	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil {
		return "", &AppError{Code: 401, Message: "Invalid credentials", Details: "Incorrect password"}
	}

	// Create JWT claims.
	claims := &models.Claims{
		UserID: user.ID,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			Issuer:    "bank-api",
		},
	}

	// Create and sign the token.
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString([]byte(s.jwtKey))
	if err != nil {
		return "", &AppError{Code: 500, Message: "Failed to sign token", Details: err.Error(), Err: err}
	}

	return tokenString, nil
}

// ValidateToken validates a JWT and returns the claims.
func (s *authService) ValidateToken(tokenString string) (*models.Claims, error) {
	claims := &models.Claims{}
	token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
		return []byte(s.jwtKey), nil
	})

	if err != nil {
		// Distinguish between different parsing errors for better diagnostics
		if ve, ok := err.(*jwt.ValidationError); ok {
			if ve.Errors&jwt.ValidationErrorMalformed != 0 {
				return nil, &AppError{Code: 401, Message: "Invalid token", Details: "Malformed token"}
			} else if ve.Errors&(jwt.ValidationErrorExpired|jwt.ValidationErrorNotValidYet) != 0 {
				return nil, &AppError{Code: 401, Message: "Invalid token", Details: "Token expired or not yet valid"}
			}
		}
		return nil, &AppError{Code: 401, Message: "Invalid token", Details: err.Error(), Err: err}
	}

	if !token.Valid {
		return nil, &AppError{Code: 401, Message: "Invalid token", Details: "Token is not valid"}
	}

	return claims, nil
}


Файл: internal\services\service.go
Содержимое:
package services

import (
	"bank-api/internal/models"
	"crypto/hmac"
	"crypto/sha256"
	"database/sql"
	"encoding/hex"
	"errors"
	"fmt"
	"golang.org/x/crypto/bcrypt"
)

type Service struct {
	db *sql.DB
}

func NewService(db *sql.DB) *Service {
	return &Service{db: db}
}

func (s *Service) Login(username, password string) (string, error) {
	var user struct {
		ID       int
		Password string
	}

	err := s.db.QueryRow("SELECT id, password FROM users WHERE username = ?",
		username).Scan(&user.ID, &user.Password)
	if err != nil {
		return "", err
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil {
		return "", errors.New("неверный пароль")
	}

	// Генерация JWT токена
	token := "jwt_token" // Упрощено
	return token, nil
}

func (s *Service) GetAccounts(userID int) ([]models.Account, error) {
	rows, err := s.db.Query("SELECT id, balance FROM accounts WHERE user_id = ?", userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var accounts []models.Account
	for rows.Next() {
		var acc models.Account
		if err := rows.Scan(&acc.ID, &acc.Balance); err != nil {
			return nil, err
		}
		accounts = append(accounts, acc)
	}

	return accounts, nil
}

func (s *Service) Deposit(userID int, accountID string, amount float64) error {
	_, err := s.db.Exec("UPDATE accounts SET balance = balance + ? WHERE id = ? AND user_id = ?",
		amount, accountID, userID)
	return err
}

func (s *Service) Withdraw(userID int, accountID string, amount float64) error {
	_, err := s.db.Exec("UPDATE accounts SET balance = balance - ? WHERE id = ? AND user_id = ? AND balance >= ?",
		amount, accountID, userID, amount)
	return err
}

func (s *Service) Transfer(userID int, req *models.TransferRequest) error {
	tx, err := s.db.Begin()
	if err != nil {
		return err
	}
	defer tx.Rollback()

	// Проверяем владельца счета
	var balance float64
	err = tx.QueryRow("SELECT balance FROM accounts WHERE id = ? AND user_id = ?",
		req.FromID, userID).Scan(&balance)
	if err != nil {
		return err
	}

	if balance < req.Amount {
		return errors.New("недостаточно средств")
	}

	// Выполняем перевод
	_, err = tx.Exec("UPDATE accounts SET balance = balance - ? WHERE id = ?",
		req.Amount, req.FromID)
	if err != nil {
		return err
	}

	_, err = tx.Exec("UPDATE accounts SET balance = balance + ? WHERE id = ?",
		req.Amount, req.ToID)
	if err != nil {
		return err
	}

	return tx.Commit()
}

func CalculateBalanceHash(balance float64, accountID int, secretKey string) string {
	h := hmac.New(sha256.New, []byte(secretKey))
	data := fmt.Sprintf("%f:%d", balance, accountID)
	h.Write([]byte(data))
	return hex.EncodeToString(h.Sum(nil))
}


Файл: internal\services\transaction_service.go
Содержимое:
// Path: internal/services/transaction_service.go
package services

import (
	"bank-api/internal/models"
	"bank-api/pkg/utils"
	"database/sql"
	"errors"
	"fmt"
)

// TransactionService handles transaction-related operations.
type TransactionService interface {
	ProcessDeposit(req *models.TransactionRequest, claims *models.Claims) error
	ProcessWithdraw(req *models.TransactionRequest, claims *models.Claims) error
	ProcessTransfer(req *models.TransferRequest, claims *models.Claims) error
}

type transactionService struct {
	db        *sql.DB
	secretKey string
}

// NewTransactionService creates a new TransactionService.
func NewTransactionService(db *sql.DB, secretKey string) TransactionService {
	return &transactionService{
		db:        db,
		secretKey: secretKey,
	}
}

// AppError is a custom error type that includes an HTTP status code.
type AppError struct {
	Code    int    `json:"-"`
	Message string `json:"message"`
	Details string `json:"details"`
	Err     error  `json:"-"`
}

func (e *AppError) Error() string {
	return fmt.Sprintf("AppError: %s (Code: %d, Details: %s)", e.Message, e.Code, e.Details)
}

// ProcessDeposit handles a deposit transaction.
func (s *transactionService) ProcessDeposit(req *models.TransactionRequest, claims *models.Claims) error {
	if req.Amount <= 0 {
		return &AppError{Code: 400, Message: "Invalid deposit amount", Details: "Amount must be positive"}
	}

	tx, err := s.db.Begin()
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to start transaction", Details: err.Error(), Err: err}
	}
	defer tx.Rollback()

	// Check if the account exists and belongs to the user.
	var (
		existingBalance float64
		balanceHash     string
	)

	err = tx.QueryRow(`SELECT balance, balance_hash FROM accounts WHERE id = ? AND user_id = ?`, req.AccountID, claims.UserID).Scan(&existingBalance, &balanceHash)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return &AppError{Code: 404, Message: "Account not found or access denied", Details: fmt.Sprintf("account_id: %d, user_id: %d", req.AccountID, claims.UserID)}
		}
		return &AppError{Code: 500, Message: "Failed to query account", Details: err.Error(), Err: err}
	}

	// Verify balance hash
	expectedHash := utils.CreateHMAC(fmt.Sprintf("%f:%d", existingBalance, req.AccountID), []byte(s.secretKey))
	if balanceHash != expectedHash {
		return &AppError{Code: 500, Message: "Balance integrity check failed", Details: fmt.Sprintf("account_id: %d", req.AccountID)}
	}

	// Update the account balance and hash.
	newBalance := existingBalance + req.Amount
	newBalanceHash := utils.CreateHMAC(fmt.Sprintf("%f:%d", newBalance, req.AccountID), []byte(s.secretKey))
	_, err = tx.Exec(`UPDATE accounts SET balance = ?, balance_hash = ? WHERE id = ?`, newBalance, newBalanceHash, req.AccountID)
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to update account balance", Details: err.Error(), Err: err}
	}
	req.TransactionID = utils.GenerateTransactionID() // Генерация transactionID

	// Insert the transaction record.
	_, err = tx.Exec(`
        INSERT INTO transactions (id, to_account_id, amount, type, status, created_at)
        VALUES (?, ?, ?, ?, ?, ?)`,
		req.TransactionID, req.AccountID, req.Amount, "deposit", "completed", utils.GetCurrentTimestamp())
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to insert transaction record", Details: err.Error(), Err: err}
	}

	if err := tx.Commit(); err != nil {
		return &AppError{Code: 500, Message: "Failed to commit transaction", Details: err.Error(), Err: err}
	}
	return nil
}

// ProcessWithdraw handles a withdrawal transaction.
func (s *transactionService) ProcessWithdraw(req *models.TransactionRequest, claims *models.Claims) error {
	if req.Amount <= 0 {
		return &AppError{Code: 400, Message: "Invalid withdrawal amount", Details: "Amount must be positive"}
	}

	tx, err := s.db.Begin()
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to start transaction", Details: err.Error(), Err: err}
	}
	defer tx.Rollback()

	// Check if the account exists, belongs to the user, and has sufficient funds.
	var (
		existingBalance float64
		balanceHash     string
	)
	err = tx.QueryRow(`SELECT balance, balance_hash FROM accounts WHERE id = ? AND user_id = ?`, req.AccountID, claims.UserID).Scan(&existingBalance, &balanceHash)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return &AppError{Code: 404, Message: "Account not found or access denied", Details: fmt.Sprintf("account_id: %d, user_id: %d", req.AccountID, claims.UserID)}
		}
		return &AppError{Code: 500, Message: "Failed to query account", Details: err.Error(), Err: err}
	}

	// Verify balance hash
	expectedHash := utils.CreateHMAC(fmt.Sprintf("%f:%d", existingBalance, req.AccountID), []byte(s.secretKey))
	if balanceHash != expectedHash {
		return &AppError{Code: 500, Message: "Balance integrity check failed", Details: fmt.Sprintf("account_id: %d", req.AccountID)}
	}

	if existingBalance < req.Amount {
		return &AppError{Code: 400, Message: "Insufficient funds", Details: fmt.Sprintf("account_id: %d, balance: %f, requested: %f", req.AccountID, existingBalance, req.Amount)}
	}

	// Update account balance and hash.
	newBalance := existingBalance - req.Amount
	newBalanceHash := utils.CreateHMAC(fmt.Sprintf("%f:%d", newBalance, req.AccountID), []byte(s.secretKey))
	_, err = tx.Exec(`UPDATE accounts SET balance = ?, balance_hash = ? WHERE id = ? AND user_id = ?`, newBalance, newBalanceHash, req.AccountID, claims.UserID)
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to update account balance", Details: err.Error(), Err: err}
	}
	req.TransactionID = utils.GenerateTransactionID() // Генерация transactionID

	// Insert transaction record.
	_, err = tx.Exec(`
        INSERT INTO transactions (id, from_account_id, amount, type, status, created_at)
        VALUES (?, ?, ?, ?, ?, ?)`,
		req.TransactionID, req.AccountID, req.Amount, "withdraw", "completed", utils.GetCurrentTimestamp())
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to insert transaction record", Details: err.Error(), Err: err}
	}

	if err := tx.Commit(); err != nil {
		return &AppError{Code: 500, Message: "Failed to commit transaction", Details: err.Error(), Err: err}
	}
	return nil
}

// ProcessTransfer handles a fund transfer between two accounts.
// ProcessTransfer handles a fund transfer between two accounts.
func (s *transactionService) ProcessTransfer(req *models.TransferRequest, claims *models.Claims) error {
	if req.Amount <= 0 {
		return &AppError{Code: 400, Message: "Invalid transfer amount", Details: "Amount must be positive"}
	}
	if req.FromID == req.ToID {
		return &AppError{Code: 400, Message: "Invalid transfer", Details: "Source and destination accounts must be different"}
	}

	tx, err := s.db.Begin()
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to start transaction", Details: err.Error(), Err: err}
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		} else {
			tx.Commit()
		}
	}()

	// Check if the source account exists, belongs to the user, and has sufficient funds.
	var (
		fromBalance     float64
		fromBalanceHash string
	)
	err = tx.QueryRow(`SELECT balance, balance_hash FROM accounts WHERE id = ? AND user_id = ?`, req.FromID, claims.UserID).Scan(&fromBalance, &fromBalanceHash)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return &AppError{Code: 404, Message: "Source account not found or access denied", Details: fmt.Sprintf("account_id: %d, user_id: %d", req.FromID, claims.UserID)}
		}
		return &AppError{Code: 500, Message: "Failed to query source account", Details: err.Error(), Err: err}
	}

	// Verify balance hash of the source account.
	expectedFromHash := utils.CreateHMAC(fmt.Sprintf("%f:%d", fromBalance, req.FromID), []byte(s.secretKey))
	if fromBalanceHash != expectedFromHash {
		return &AppError{Code: 500, Message: "Source account balance integrity check failed", Details: fmt.Sprintf("account_id: %d", req.FromID)}
	}

	if fromBalance < req.Amount {
		return &AppError{Code: 400, Message: "Insufficient funds in source account", Details: fmt.Sprintf("account_id: %d, balance: %f, requested: %f", req.FromID, fromBalance, req.Amount)}
	}

	// Check if the destination account exists.
	var (
		toBalance     float64
		toBalanceHash string
	)

	err = tx.QueryRow(`SELECT balance, balance_hash FROM accounts WHERE id = ?`, req.ToID).Scan(&toBalance, &toBalanceHash)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return &AppError{Code: 404, Message: "Destination account not found", Details: fmt.Sprintf("account_id: %d", req.ToID)}
		}
		return &AppError{Code: 500, Message: "Failed to query destination account", Details: err.Error(), Err: err}
	}

	// Verify balance hash of the destination account
	expectedToHash := utils.CreateHMAC(fmt.Sprintf("%f:%d", toBalance, req.ToID), []byte(s.secretKey))
	if toBalanceHash != expectedToHash {
		return &AppError{Code: 500, Message: "Destination account balance integrity check failed", Details: fmt.Sprintf("account_id: %d", req.ToID)}
	}

	// Perform the transfer (update balances and hashes).
	newFromBalance := fromBalance - req.Amount
	newFromBalanceHash := utils.CreateHMAC(fmt.Sprintf("%f:%d", newFromBalance, req.FromID), []byte(s.secretKey))
	_, err = tx.Exec(`UPDATE accounts SET balance = ?, balance_hash = ? WHERE id = ? AND user_id = ?`, newFromBalance, newFromBalanceHash, req.FromID, claims.UserID)
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to update source account balance", Details: err.Error(), Err: err}
	}

	newToBalance := toBalance + req.Amount
	newToBalanceHash := utils.CreateHMAC(fmt.Sprintf("%f:%d", newToBalance, req.ToID), []byte(s.secretKey))
	_, err = tx.Exec(`UPDATE accounts SET balance = ?, balance_hash = ? WHERE id = ?`, newToBalance, newToBalanceHash, req.ToID)
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to update destination account balance", Details: err.Error(), Err: err}
	}

	transactionID := utils.GenerateTransactionID()
	// Кароче успешная транзакция.
	_, err = tx.Exec(`
        INSERT INTO transactions (id, from_account_id, to_account_id, amount, type, status, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?)`,
		transactionID, req.FromID, req.ToID, req.Amount, "transfer", "completed", utils.GetCurrentTimestamp())
	if err != nil {
		return &AppError{Code: 500, Message: "Failed to insert transaction record", Details: err.Error(), Err: err}
	}

	if err := tx.Commit(); err != nil {
		return &AppError{Code: 500, Message: "Failed to commit transaction", Details: err.Error(), Err: err}
	}
	return nil
}


Файл: pkg\database\database.go
Содержимое:
// Path: pkg/database/database.go
package database

import (
	"database/sql"
	"fmt"
	_ "github.com/mattn/go-sqlite3"
)

// InitDB initializes the database and creates tables if they don't exist.
func InitDB(path string) (*sql.DB, error) {
	db, err := sql.Open("sqlite3", path)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	// Enable foreign key support.
	_, err = db.Exec("PRAGMA foreign_keys = ON;")
	if err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to enable foreign keys: %w", err)
	}

	if err := createTables(db); err != nil {
		db.Close()
		return nil, err
	}

	return db, nil
}

// создаем таблитцу датабазы
func createTables(db *sql.DB) error {
	// Use a single transaction for table creation.
	tx, err := db.Begin()
	if err != nil {
		return fmt.Errorf("failed to start transaction: %w", err)
	}
	defer tx.Rollback() // Rollback if any error occurs.

	queries := []string{
		`CREATE TABLE IF NOT EXISTS users (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        username TEXT UNIQUE NOT NULL,
                        password TEXT NOT NULL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );`,
		`CREATE TABLE IF NOT EXISTS accounts (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        balance REAL NOT NULL DEFAULT 0,
                        balance_hash TEXT NOT NULL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                );`,
		`CREATE TABLE IF NOT EXISTS transactions (
                        id TEXT PRIMARY KEY,
                        from_account_id INTEGER,
                        to_account_id INTEGER,
                        amount REAL NOT NULL,
                        type TEXT NOT NULL,
                        status TEXT NOT NULL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (from_account_id) REFERENCES accounts(id) ON DELETE SET NULL,
                        FOREIGN KEY (to_account_id) REFERENCES accounts(id) ON DELETE SET NULL
                );`,
		// Create indexes for faster lookups.
		`CREATE INDEX IF NOT EXISTS idx_accounts_user_id ON accounts(user_id);`,
		`CREATE INDEX IF NOT EXISTS idx_transactions_from_account_id ON transactions(from_account_id);`, // Corrected index name
		`CREATE INDEX IF NOT EXISTS idx_transactions_to_account_id ON transactions(to_account_id);`,     // Corrected index name
	}

	for _, query := range queries {
		_, err = tx.Exec(query)
		if err != nil {
			return fmt.Errorf("failed to execute query: %s, error: %w", query, err)
		}
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}


Файл: pkg\utils\utils.go
Содержимое:
// Path: pkg/utils/utils.go
package utils

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"math/rand"
	"time"
)

// Еебать старье, крч просто функция по рандомному созданию стринга
func GenerateRandomString(length int) string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	seededRand := rand.New(rand.NewSource(time.Now().UnixNano()))
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[seededRand.Intn(len(charset))]
	}
	return string(b)
}

// CreateHMAC создает хэш HMAC-SHA256 для защиты
func CreateHMAC(data string, secret []byte) string {
	h := hmac.New(sha256.New, secret)
	h.Write([]byte(data))
	return hex.EncodeToString(h.Sum(nil))
}

// Генератор транзакционных ID
func GenerateTransactionID() string {
	timestamp := time.Now().UnixNano()
	random := GenerateRandomString(8)
	return fmt.Sprintf("%d-%s", timestamp, random)
}

// GetCurrentTimestamp возвращает текущую временную метку в формате RFC3339.
func GetCurrentTimestamp() string {
	return time.Now().Format(time.RFC3339)
}

func CalculateBalanceHash(balance float64, accountID int, secretKey string) string {
	h := hmac.New(sha256.New, []byte(secretKey))
	data := fmt.Sprintf("%f:%d", balance, accountID)
	h.Write([]byte(data))
	return hex.EncodeToString(h.Sum(nil))
}


